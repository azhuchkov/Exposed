package org.jetbrains.exposed.sql.statements

import org.jetbrains.exposed.sql.*
import java.sql.PreparedStatement
import java.util.*

class BatchInsertStatement(val table: Table, val _ignore: Boolean = false): Statement<List<Int>>(StatementType.INSERT, listOf(table)) {

    val data = ArrayList<LinkedHashMap<Column<*>, Any?>>()

    fun addBatch() {
        data.add(LinkedHashMap())
    }

    operator fun <T> set(column: Column<T>, value: T) {
        val values = data.last()

        if (values.containsKey(column)) {
            error("$column is already initialized")
        }

        values.put(column, column.columnType.valueToDB(value))
    }

    override fun arguments(): Iterable<Iterable<Pair<ColumnType, Any?>>> = listOf(data.map {
        single -> table.columns.filterNot { it.columnType.autoinc }.map { it.columnType to (single[it] ?: it.defaultValue) }
    }.flatten())

    override fun prepareSQL(transaction: Transaction): String {
        if (data.isNotEmpty()) {
            val columns = table.columns.filterNot { it.columnType.autoinc }

            val values = buildString {
                append("VALUES ")
                val paramsPlaceholder = columns.map { "?" }.joinToString(", ", prefix = "(", postfix = "),")

                append(paramsPlaceholder.repeat(data.size).removeSuffix(","))
            }

            return transaction.db.dialect.insert(_ignore, table, columns, values, transaction)
        }

        error("No data provided to insert")
    }

    override fun PreparedStatement.executeInternal(transaction: Transaction): List<Int> {
        if (data.isEmpty()) return emptyList()

        val count = executeUpdate()

        assert(count == data.size) { "Number of results don't match number of entries in batch" }

        val autoGeneratedKeys = arrayListOf<Int>()

        if (table.columns.any { it.columnType.autoinc }) {
            val rs = generatedKeys!!
            while (rs.next()) {
                autoGeneratedKeys.add(rs.getInt(1))
            }

            if (autoGeneratedKeys.size == 1 && count > 1) {
                // H2 only returns one last generated keys...
                var id = autoGeneratedKeys.first()

                while (autoGeneratedKeys.size < count) {
                    id -= 1
                    autoGeneratedKeys.add(0, id)
                }
            }

            assert(autoGeneratedKeys.isEmpty() || autoGeneratedKeys.size == count) { "Number of autoincs doesn't match number of batch entries" }
        }
        return autoGeneratedKeys
    }

}
